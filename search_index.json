[["index.html", "fwdpy11 recipes 1 Preface", " fwdpy11 recipes Kevin R Thornton 2021-01-18 1 Preface This book provides additional recipes for the fwdpy11 simulation software. The recipes complement examples found in the primary documentation. Some recipes may be repeated here. The book is written using R Markdown. The Python code blocks are executed via reticulate. The book is always current with respect to the current fwdpy11 release. The contents of this book are generated using fwdpy11 version 0.12.0. "],["introduction.html", "2 Introduction 2.1 Key imports", " 2 Introduction 2.1 Key imports The following imports will be used throughout: import typing import matplotlib.pyplot as plt import numpy as np import pandas as pd import seaborn as sns import attr import fp11recipes import fwdpy11 The fp11recipes is a small Python module includes with the source code for this book. "],["distributions-of-effect-sizes.html", "3 Distributions of effect sizes", " 3 Distributions of effect sizes "],["genetic-maps-and-recombination.html", "4 Genetic maps and recombination", " 4 Genetic maps and recombination "],["demographic-models-soft-selection-and-discrete-demes.html", "5 Demographic models (soft selection and discrete demes)", " 5 Demographic models (soft selection and discrete demes) "],["timeseries.html", "6 Analyzing populations during a simulation 6.1 Tracking mutations over time", " 6 Analyzing populations during a simulation 6.1 Tracking mutations over time This section makes use of keyword-only arguments to fwdpy11.evolvets. Many of those arguments are somewhat experimental in nature. This recipe covers tracking the frequencies of all mutations over time during a simulation using a time series recorder. Such tracking requires care, as it is not a common use case. Internally, fwdpy11 doesn’t really care about how often each mutation is present in the population. Usually, the simulation only needs to know if a mutation was removed by simplification, or remains somewhere in the ancestry of the population. Therefore, to track frequencies, we need to work a little harder. The following listing shows how we will track frequencies. The key elements are: We initialize instances of the recorder with a “burn-in” time. We do not do anything until the population’s generation is greater than that value. This check allows us to more quickly simulate to equilibrium, which we’ll explain in more detail below. We record trajectories in a Python dictionary. The key will be tuples of (origin time, position, effect size). The value will be the count of the mutation each generation. We take special care to not record the count of a fixation over and over again. @attr.s(auto_attribs=True) class PyFreqTracker(object): burnin_time: int trajectories: typing.Dict = attr.ib(default=attr.Factory(dict)) def __call__( self, pop: fwdpy11.DiploidPopulation, sampler: fwdpy11.SampleRecorder ) -&gt; None: if pop.generation &gt; self.burnin_time: for c, m in zip(pop.mcounts, pop.mutations): if c &gt; 0 and c &lt;= 2 * pop.N: k = (m.g, m.pos, m.s) if k in self.trajectories: # Make sure that we only record a fixation once. if self.trajectories[k][-1] &lt; 2 * pop.N: self.trajectories[k].append(c) else: self.trajectories[k] = [c] Now, let’s simulate a model of a high rate of recurrent hitch-hiking: pdict = { &quot;nregions&quot;: [], &quot;sregions&quot;: [fwdpy11.ExpS(beg=0, end=1, weight=1, mean=0.2)], &quot;recregions&quot;: [fwdpy11.PoissonInterval(0, 1, 1e-2)], &quot;gvalue&quot;: [fwdpy11.Multiplicative(2.0)], &quot;rates&quot;: (0.0, 1e-2, None), &quot;simlen&quot;: 100, } params = fwdpy11.ModelParams(**pdict) pop = fwdpy11.DiploidPopulation(100, 1.0) rng = fwdpy11.GSLrng(42) recorder = PyFreqTracker(0) fwdpy11.evolvets( rng, pop, params, 10, recorder, track_mutation_counts=True, suppress_table_indexing=False, ) The arguments to fwdpy11.evolvets need some explanation. We simplify every 10 generations. Setting track_mutation_counts=True tells the function to obtain mutation counts from diploid genomes every generation. Setting suppress_table_indexing=False tells fwdpy11 to index the tables after every simplification event. In generations when simplification occurs, mutation counts are obtained from trees and not from genomes. The current default behavior of fwdpy11.evolvets is to set suppress_table_indexing=False. However, future releases will likely set that to True. This recipe is written in anticipation of that change. 6.1.1 Converting trajectories to data frames We can easily do a lot of analysis from recorder.trajectories. However, there are good reasons to convert things into common formats for analysis, such as the pandas data frame: def traj2df(trajectories: typing.Dict, N: int) -&gt; pd.DataFrame: dfs = [] for key, value in trajectories.items(): df = pd.DataFrame( { &quot;generation&quot;: np.arange(len(value), dtype=np.uint32) + key[0], &quot;frequency&quot;: np.array(value) / (2 * N), &quot;origin_time&quot;: [key[0]] * len(value), &quot;position&quot;: [key[1]] * len(value), &quot;effect_size&quot;: [key[2]] * len(value), } ) dfs.append(df) return pd.concat(dfs) 6.1.2 Plotting the trajectories Here is a function to plot all trajectories, eliminating those with sojourn times \\(&lt; minlen\\) generations: def plot_traj_df( df: pd.DataFrame, *, minlen: int, selected_alpha=1.0, neutral_alpha=1.0 ) -&gt; None: if minlen &lt; 0: raise ValueError(f&quot;minlen must be non-negative, got {minlen}&quot;) plt.figure() for n, g in df.groupby([&quot;origin_time&quot;, &quot;position&quot;, &quot;effect_size&quot;]): if len(g.index) &gt;= minlen: if g.effect_size[0] == 0.0: plt.plot(g.generation, g.frequency, linestyle=&quot;--&quot;, alpha=neutral_alpha) else: plt.plot(g.generation, g.frequency, alpha=selected_alpha) plt.xlabel(&quot;Time (generation)&quot;) plt.ylabel(&quot;Frequency&quot;) plt.show() df = traj2df(recorder.trajectories, pop.N) plot_traj_df(df, minlen=10) Figure 6.1: So many sweeps! 6.1.3 Tracking the frequencies of neutral mutations One generally doesn’t simulate neutral mutations. However, certain questions regarding linked selection may force you to do so. Neutral mutations do not get added to diploid genomes (in order to save memory), and thus will their counts are not obtained via track_mutation_counts=True. The solution is: Simplify every generation, so that counts can be obtained from the trees. pdict = { # Add a region for neutral mutations: &quot;nregions&quot;: [fwdpy11.Region(0, 1, 1)], &quot;sregions&quot;: [fwdpy11.ExpS(beg=0, end=1, weight=1, mean=0.2)], &quot;recregions&quot;: [fwdpy11.PoissonInterval(0, 1, 1e-2)], &quot;gvalue&quot;: [fwdpy11.Multiplicative(2.0)], # Add a mutation rate for neutral mutations: &quot;rates&quot;: (1e-2, 1e-2, None), &quot;simlen&quot;: 100, } params = fwdpy11.ModelParams(**pdict) pop = fwdpy11.DiploidPopulation(100, 1.0) rng = fwdpy11.GSLrng(54321) recorder = PyFreqTracker(0) fwdpy11.evolvets( rng, pop, params, 1, # Simplify every generation recorder, suppress_table_indexing=False, ) Here, we do not need track_mutation_counts=True because simplifying each generation ends up accomplishing the same thing (for neutral and for selected variants). Let’s take a look at the plot. We will reduce the opacity of selected variants to make the neutral ones pop a bit more: df = traj2df(recorder.trajectories, pop.N) plot_traj_df(df, minlen=10, selected_alpha=0.10) Figure 6.2: Hitch-hiking! Neutral mutation trajectories are dashed lines. The selected variant tajectories are shown with reduced opacity. 6.1.4 Other considerations This recipe needs adjustment for the following cases: Tracking mutation frequencies with respect to deme. Tracking mutation frequencies in demes that change size. While this tracker is quite simple to write, performance may be an issue for very large simulations. To further improve performance, see 7.1. "],["extending-fwdpy11-with-c.html", "7 Extending fwdpy11 with C++ 7.1 Analyzing population during a simulation 7.2 Building with cmake", " 7 Extending fwdpy11 with C++ 7.1 Analyzing population during a simulation This section revisits concepts from Chapter 6. 7.1.1 Tracking mutations over time 7.1.1.1 Running the tracker This recipe revisits the Python frequency tracker using a tracker written in C++. The tracker’s code is shown below. from fp11recipes.freqtrackercpp import FreqTracker pdict = { &quot;nregions&quot;: [], &quot;sregions&quot;: [fwdpy11.ExpS(beg=0, end=1, weight=1, mean=0.2)], &quot;recregions&quot;: [fwdpy11.PoissonInterval(0, 1, 1e-2)], &quot;gvalue&quot;: [fwdpy11.Multiplicative(2.0)], &quot;rates&quot;: (0.0, 1e-2, None), &quot;simlen&quot;: 100, } params = fwdpy11.ModelParams(**pdict) pop = fwdpy11.DiploidPopulation(100, 1.0) rng = fwdpy11.GSLrng(42) recorder = FreqTracker(0) fwdpy11.evolvets( rng, pop, params, 10, recorder, track_mutation_counts=True, suppress_table_indexing=False, ) We will reuse code from the previous recipe to convert the output to a data frame and plot: df = traj2df(recorder.trajectories, pop.N) plot_traj_df(df, minlen=10); Figure 7.1: So many sweeps, again. This should look identical to Figure 6.1. 7.1.2 The C++ code The code is relatively straightforward C++. The main difference from the Python version is that we use unordered_map as our associative container. C++ does not have hashing functions for tuples, meaning that we have to adjust our scheme a bit. Here, we use nested associative containers. The outer container hashes the mutations’ origin times. The inner container hashes position. We manually define a property to convert the data to a dict. #include &lt;cstdint&gt; #include &lt;map&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; #include &lt;fwdpy11/evolvets/SampleRecorder.hpp&gt; #include &lt;fwdpy11/types/DiploidPopulation.hpp&gt; #include &lt;pybind11/functional.h&gt; #include &lt;pybind11/pybind11.h&gt; #include &lt;pybind11/stl.h&gt; namespace py = pybind11; struct FreqTracker { // Origin time, position, effect size using key_type = std::tuple&lt;std::uint32_t, double, double&gt;; using trajectory = std::vector&lt;std::uint32_t&gt;; // We record trajectories by nesting hashed associative // containers. The outer hash is on origin time. The inner // is on position. Finally, the pair is effect size + the // frequency trajectory. using map_type = std::unordered_map&lt; std::uint32_t, std::unordered_map&lt;double, std::pair&lt;double, trajectory&gt;&gt;&gt;; map_type trajectories; std::uint32_t burnin_time; FreqTracker(std::uint32_t burnin) : trajectories{}, burnin_time{burnin} {} inline void operator()(const fwdpy11::DiploidPopulation&amp; pop, fwdpy11::SampleRecorder&amp; /*unused*/) { if (pop.generation &gt; burnin_time) { for (std::size_t i = 0; i &lt; pop.mcounts.size(); ++i) { if (pop.mcounts[i] &gt; 0 &amp;&amp; pop.mcounts[i] &lt;= 2 * pop.N) { auto origin = pop.mutations[i].g; auto origin_itr = trajectories.find(origin); if (origin_itr == end(trajectories)) { trajectories[origin][pop.mutations[i].pos] = std::make_pair(pop.mutations[i].s, trajectory{pop.mcounts[i]}); } else { auto pos_itr = origin_itr-&gt;second.find(pop.mutations[i].pos); if (pos_itr == end(origin_itr-&gt;second)) { origin_itr-&gt;second[pop.mutations[i].pos] = std::make_pair(pop.mutations[i].s, trajectory{pop.mcounts[i]}); } else { if (pos_itr-&gt;second.second.back() &lt; 2 * pop.N) { pos_itr-&gt;second.second.push_back(pop.mcounts[i]); } } } } } } } // Make a copy of the data that Python will see // as a dict. // While we could rely on pybind11 to auto-convert // from a C++ map to a Python dict, doing so // would give 3 total copies in memory due to // temporaries. So instead, we go straight // to a dict using pybind11&#39;s API. py::dict get_trajectories() const { py::dict rv; for (auto&amp;&amp; origin : trajectories) { for (auto&amp;&amp; position : origin.second) { // Make a Python tuple auto key = py::make_tuple(origin.first, position.first, position.second.first); // Rely on auto-conversion of c++ vector // to Python list, via pybind11/stl.h included above. rv[key] = position.second.second; } } return rv; } }; PYBIND11_MODULE(freqtrackercpp, m) { py::class_&lt;FreqTracker&gt;(m, &quot;FreqTracker&quot;) .def(py::init&lt;std::uint32_t&gt;(), py::arg(&quot;burnin_time&quot;)) // This is __init__ .def(&quot;__call__&quot;, &amp;FreqTracker::operator()) // This makes it a valid // Python callable .def_property_readonly(&quot;trajectories&quot;, &amp;FreqTracker::get_trajectories); // Get the data as a // dict in Python. } 7.2 Building with cmake It is arguably easiest to build extension with cmake. The pybind11 documentation gives instructions on how to do so. The CMakeLists.txt to build the C++ components of the fp11recipes module accompanying this book looks like this: cmake_minimum_required(VERSION 2.8.12) project(fp11recipes_modules) # As of 0.8.0, fwdpy11 # is compiled with the C++14 language # standard (-std=c++14) set(CMAKE_CXX_EXTENSIONS OFF) set(CMAKE_CXX_STANDARD 14) find_package(pybind11) message(STATUS &quot;Found pybind11: ${pybind11_VERSION}&quot;) if(${pybind11_VERSION} VERSION_LESS &#39;2.6.0&#39;) message(FATAL_ERROR &quot;pybind11 version must be &gt;= &#39;2.6.0&#39;&quot;) endif() execute_process(COMMAND python3 -m fwdpy11 --fwdpy11_headers OUTPUT_VARIABLE FP11HEADERS) execute_process(COMMAND python3 -m fwdpy11 --fwdpp_headers OUTPUT_VARIABLE FWDPPHEADERS) find_package(GSL REQUIRED) include_directories(BEFORE ${FP11HEADERS} ${FWDPPHEADERS}) message(STATUS &quot;GSL headers in ${GSL_INCLUDE_DIRS}&quot;) include_directories(BEFORE ${GSL_INCLUDE_DIRS}) set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall&quot;) pybind11_add_module(freqtrackercpp MODULE freqtrackercpp.cc) target_link_libraries(freqtrackercpp PRIVATE GSL::gsl GSL::gslcblas) "]]
